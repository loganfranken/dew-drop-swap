{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./script/scenes/TitleScene.js","webpack:///./script/Utility.js","webpack:///./script/TileState.js","webpack:///./script/TileGenerationBehavior.js","webpack:///./script/TileType.js","webpack:///./script/scenes/RoundScene.js","webpack:///./script/ActionQueue.js","webpack:///./script/TileGrid.js","webpack:///./script/Tile.js","webpack:///./script/ScoreDisplay.js","webpack:///./script/Timer.js","webpack:///./script/DialogManager.js","webpack:///./script/DialogScript.js","webpack:///./script/Guide.js","webpack:///./script/scenes/GameOverScene.js","webpack:///./script/main.js"],"names":["enumerable","get","getter","value","key","bind","module","Object","prototype","hasOwnProperty","call","object","property","super","self","this","add","text","startBtn","setInteractive","on","scene","start","level","getRandomItem","items","Math","floor","random","length","name","imageKey","score","queue","selectedTiles","tileGrid","scoreDisplay","timer","guide","comboCount","totalMatches","load","image","data","queuedActions","currentAction","shift","action","push","then","tileGridWidth","tileGridHeight","tileSize","offsetX","offsetY","onTileSelect","onTileMatch","tileImageContainer","playAreaOffset","tileGenerationBehavior","TileGenerationBehavior","y","x","createTile","getTileType","context","container","forEachTile","tile","create","maskShape","make","graphics","fillStyle","fillRect","mask","Phaser","Display","Masks","GeometryMask","matchedTiles","getMatches","destroys","forEach","t","destroy","Promise","all","state","TileState","drops","closestY","closestTile","getTileDrop","forEachPlayableTile","adjustedY","firstTile","secondTile","firstTileX","firstTileY","firstTileGridX","tileGridX","firstTileGridY","tileGridY","secondTileX","secondTileY","secondTileGridX","secondTileGridY","firstSwap","updatePosition","secondSwap","targetGridX","targetGridY","isPlayable","targetTileType","tileType","matchedXTiles","matchedYTiles","currX","currTile","currY","callback","isActivated","setTintFill","clearTint","resolve","reject","tweens","targets","ease","duration","onComplete","alpha","remove","getTileX","getTileY","behavior","aboveTile","belowTile","leftTile","rightTile","TileType","filter","map","scoreText","comboText","setText","seconds","tick","time","addEvent","delay","callbackScope","loop","minutes","script","introMessages","getDisplayTileMatchMessages","getScript","messageTimer","currMessageIndex","queuedMessages","speechBubbleGraphics","color","speechBubble","Geom","Rectangle","fillRectShape","input","pointer","contains","paused","speechBubbleText","characterGraphics","character","queueMessages","messages","currMessage","message","slice","isActionRunning","hasActions","next","update","canSelect","deactivate","activate","selectedTile","xDiff","abs","yDiff","firstSelectedTile","secondSelectedTile","swapTiles","hasMatches","updateScore","displayTileMatchMessage","updateCombo","finalScore","startOverBtn","config","type","AUTO","width","height","TitleScene","RoundScene","GameOverScene","Game"],"mappings":"aACA,SAGA,cAGA,QACA,oBAGA,YACA,IACA,KACA,YAUA,OANA,mCAGA,OAGA,UAKA,MAGA,MAGA,oBACA,UACA,2BAA2CA,YAAY,EAAMC,IAAKC,KAKlE,gBACA,gDACA,4CAAyDC,MAAO,WAEhE,sCAAkDA,OAAO,KAQzD,kBAEA,GADA,cACA,aACA,qDACA,0BAGA,GAFA,OACA,mCAA0CH,YAAY,EAAMG,MAAOA,IACnE,2DAAiH,OAAOA,EAAMC,IAAQC,KAAK,KAAMD,IACjJ,UAIA,gBACA,sBACA,WAA4B,OAAOE,EAAgB,SACnD,WAAkC,OAAOA,GAEzC,OADA,aACA,GAIA,kBAAuD,OAAOC,OAAOC,UAAUC,eAAeC,KAAKC,EAAQC,IAG3G,OAIA,S,sCClFe,iCAEX,cAEIC,MAAM,cAGV,SAEI,MAAMC,EAAOC,KAGbA,KAAKC,IAAIC,KAAK,GAAI,GAAI,gBAGtB,MAAMC,EAAWH,KAAKC,IAAIC,KAAK,GAAI,GAAI,cACvCC,EAASC,iBACTD,EAASE,GAAG,cAAe,KAAQN,EAAKO,MAAMC,MAAM,aAAc,CAAEC,MAAO,QChBnF,MAAMC,EAAiBC,GACZA,EAAMC,KAAKC,MAAMD,KAAKE,SAAWH,EAAMI,SCFnC,MACH,EADG,EAEA,ECFA,EACL,EADK,EAEF,ECFE,GACX,CAAEC,KAAM,OAAQC,SAAU,WAC1B,CAAED,KAAM,QAASC,SAAU,WAC3B,CAAED,KAAM,MAAOC,SAAU,WACzB,CAAED,KAAM,SAAUC,SAAU,YCGjB,6BAEX,cAEIlB,MAAM,cAENE,KAAKiB,MAAQ,KACbjB,KAAKkB,MAAQ,KACblB,KAAKmB,cAAgB,KACrBnB,KAAKoB,SAAW,KAChBpB,KAAKqB,aAAe,KACpBrB,KAAKsB,MAAQ,KAEbtB,KAAKuB,MAAQ,KACbvB,KAAKQ,MAAQ,KAEbR,KAAKwB,WAAa,KAClBxB,KAAKyB,aAAe,KAGxB,UAEIzB,KAAK0B,KAAKC,MAAM,UAAW,sBAC3B3B,KAAK0B,KAAKC,MAAM,UAAW,sBAC3B3B,KAAK0B,KAAKC,MAAM,UAAW,sBAC3B3B,KAAK0B,KAAKC,MAAM,UAAW,sBAG/B,KAAKC,GAED5B,KAAKQ,MAAQoB,EAAKpB,MAGtB,SAEIR,KAAKiB,MAAQ,EACbjB,KAAKwB,WAAa,EAClBxB,KAAKyB,aAAe,EAEpBzB,KAAKkB,MAAQ,IC9CN,MAEX,cAEIlB,KAAK6B,cAAgB,GACrB7B,KAAK8B,cAAgB,KAGzB,kBAEI,OAA6B,MAAtB9B,KAAK8B,cAGhB,aAEI,OAAO9B,KAAK6B,cAAcf,OAAS,EAGvC,OAEId,KAAK8B,cAAgB9B,KAAK6B,cAAcE,QACxC/B,KAAK8B,gBAGT,KAAKE,GAED,IAAIjC,EAAOC,KACXD,EAAK8B,cAAcI,KAAK,KAAQD,IAASE,KAAK,KAAQnC,EAAK+B,cAAgB,WDqB3E9B,KAAKmB,cAAgB,GACrBnB,KAAKoB,SAAW,IE3CT,MAEX,YAAYe,EAAeC,EAAgBC,EAAUC,EAASC,EAASC,EAAcC,EAAavB,GAE9FlB,KAAKsC,QAAUA,EACftC,KAAKuC,QAAUA,EACfvC,KAAKqC,SAAWA,EAChBrC,KAAKoC,eAAiBA,EACtBpC,KAAKmC,cAAgBA,EACrBnC,KAAKoB,SAAW,GAChBpB,KAAK0C,mBAAqB,KAC1B1C,KAAK2C,eAAkB3C,KAAKoC,eAAiBpC,KAAKqC,SAElDrC,KAAKwC,aAAeA,EACpBxC,KAAKyC,YAAcA,EAEnBzC,KAAK4C,uBAAyBC,EAE9B7C,KAAKkB,MAAQA,EAKb,IAAI,IAAI4B,EAAI,EAAGA,EAAqB,EAAjBV,EAAoBU,IACvC,CACI9C,KAAKoB,SAAS0B,GAAK,GACnB,IAAI,IAAIC,EAAI,EAAGA,EAAIZ,EAAeY,IAE9B/C,KAAKoB,SAAS0B,GAAGC,GAAMD,EAAIV,EACrB,KACApC,KAAKgD,WAAWhD,KAAKiD,YAAYF,EAAGD,EAAG9C,KAAK4C,wBAAyBG,EAAGD,IAK1F,OAAOI,GAEHlD,KAAK0C,mBAAqBQ,EAAQjD,IAAIkD,YAGtCnD,KAAKoD,YAAYC,IAED,OAATA,IAKHA,EAAKC,OAAOJ,GACZlD,KAAK0C,mBAAmBzC,IAAIoD,EAAK1B,UAKrC,MAAM4B,EAAYL,EAAQM,KAAKC,WAC/BF,EAAUG,UAAU,SAAU,GAC9BH,EAAUI,SAAS3D,KAAKsC,QAAQ,EAAGtC,KAAKuC,QAAQ,EAAKvC,KAAKoC,eAAiBpC,KAAKqC,SAAWrC,KAAKmC,cAAgBnC,KAAKqC,SAAUrC,KAAKoC,eAAiBpC,KAAKqC,UAE1JrC,KAAK0C,mBAAmBkB,KAAO,IAAIC,OAAOC,QAAQC,MAAMC,aAAad,EAASK,GAGlF,OAAOL,GAEH,MAAMnD,EAAOC,KAEb,GAAGD,EAAKmB,MAAMJ,OAAS,EAEnB,OAIJ,MAAMmD,EAAelE,EAAKmE,aAEvBD,EAAanD,OAAS,GAErBf,EAAK0C,YAAYS,EAASe,GAG9B,IAAIE,EAAW,GACfF,EAAaG,QAAQC,IAAOF,EAASlC,KAAKoC,EAAEC,QAAQpB,EAASlD,KAAK0C,uBAE/DyB,EAASrD,OAAS,GAEjBf,EAAKmB,MAAMe,KAAK,IAAesC,QAAQC,IAAIL,IAI/CpE,EAAKqD,YAAY,CAACC,EAAMN,EAAGD,KAEX,OAATO,GAKAA,EAAKoB,QAAUC,IAEd3E,EAAKqB,SAAS0B,GAAGC,GAAK,QAM9B,IAAI4B,EAAQ,GACZ,IAAI,IAAI5B,EAAI,EAAGA,EAAI/C,KAAKmC,cAAeY,IACvC,CACI,IAAID,EAA2B,EAAtB9C,KAAKoC,eAAsB,EACpC,KAAMU,GAAK,GACX,CAEI,GAA2B,OAAxB/C,EAAKqB,SAAS0B,GAAGC,GACpB,CAEI,IAAI6B,EAAW9B,EAAI,EACnB,KAAM8B,GAAY,GAClB,CACI,IAAIC,EAAc9E,EAAKqB,SAASwD,GAAU7B,GACvB,OAAhB8B,IAGC9E,EAAKqB,SAAS0B,GAAGC,GAAK8B,EACtB9E,EAAKqB,SAASwD,GAAU7B,GAAK,KAC7B4B,EAAM1C,KAAKjC,KAAK8E,YAAY5B,EAAS2B,EAAa9B,EAAGD,IACrDA,KAEJ8B,KAIR9B,KAKR/C,EAAKgF,oBAAoB,CAAC1B,EAAMN,EAAGD,KAC/B,GAAY,OAATO,EACH,CACI,MAAM2B,EAAYlC,EAAI/C,EAAKqC,eAErBiB,EAAOtD,EAAKiD,WAAWjD,EAAKkD,YAAYF,EAAGD,EAAG/C,EAAK6C,wBAAyBG,EAAGiC,GACrFjF,EAAKqB,SAAS4D,GAAWjC,GAAKM,EAC9BA,EAAKC,OAAOJ,GACZnD,EAAK2C,mBAAmBzC,IAAIoD,EAAK1B,UAItCgD,EAAM7D,OAAS,GAEdf,EAAKmB,MAAMe,KAAK,IAAesC,QAAQC,IAAIG,IAInD,UAAUzB,EAAS+B,EAAWC,GAE1B,IAAInF,EAAOC,KAEXD,EAAKmB,MAAMe,KAAK,KAEZ,IAAIkD,EAAaF,EAAUlC,EACvBqC,EAAaH,EAAUnC,EACvBuC,EAAiBJ,EAAUK,UAC3BC,EAAiBN,EAAUO,UAE3BC,EAAcP,EAAWnC,EACzB2C,EAAcR,EAAWpC,EACzB6C,EAAkBT,EAAWI,UAC7BM,EAAkBV,EAAWM,UAE7BK,EAAYX,EAAWY,eAAe5C,EAASiC,EAAYC,EAAYC,EAAgBE,GAC3FxF,EAAKqB,SAASmE,GAAgBF,GAAkBH,EAEhD,IAAIa,EAAad,EAAUa,eAAe5C,EAASuC,EAAaC,EAAaC,EAAiBC,GAG9F,OAFA7F,EAAKqB,SAASwE,GAAiBD,GAAmBV,EAE3CV,QAAQC,IAAI,CAACqB,EAAWE,MAKvC,WAAWC,EAAaC,GAEpB,OAAOjG,KAAKkE,WAAW8B,EAAaC,GAAanF,OAAS,EAG9D,WAAWkF,EAAaC,GAEpB,MAAMlG,EAAOC,KACPiE,EAAe,GA6GrB,OA3GAlE,EAAKqD,YAAY,CAACC,EAAMN,EAAGD,KAEvB,QAC4B,IAAhBkD,GAA+BjD,IAAMiD,QACrB,IAAhBC,GAA+BnD,IAAMmD,EAG7C,OAGJ,IAAIjG,KAAKkG,WAAW7C,GAEhB,OAGJ,MAAM8C,EAAiB9C,EAAK+C,SACtBC,EAAgB,GAChBC,EAAgB,GAGtB,IAAIC,EAASxD,EAAI,EACjB,KAAMwD,EAAQxG,EAAKoC,eACnB,CACI,MAAMqE,EAAWzG,EAAKqB,SAAS0B,GAAGyD,GAElC,GAAe,MAAZC,GAAoBL,EAAepF,OAASyF,EAASJ,SAASrF,KAM7D,MAJAsF,EAAcpE,KAAKuE,GAOvBD,IAKJ,IADAA,EAASxD,EAAI,EACPwD,EAAQ,GACd,CACI,MAAMC,EAAWzG,EAAKqB,SAAS0B,GAAGyD,GAElC,GAAe,MAAZC,GAAoBL,EAAepF,OAASyF,EAASJ,SAASrF,KAM7D,MAJAsF,EAAcpE,KAAKuE,GAOvBD,IAIJ,IAAIE,EAAS3D,EAAI,EACjB,KAAM2D,EAAQ1G,EAAKqC,gBACnB,CACI,MAAMoE,EAAWzG,EAAKqB,SAASqF,GAAO1D,GAEtC,GAAe,MAAZyD,GAAoBL,EAAepF,OAASyF,EAASJ,SAASrF,KAM7D,MAJAuF,EAAcrE,KAAKuE,GAOvBC,IAKJ,IADAA,EAAS3D,EAAI,EACP2D,EAAQ,GACd,CACI,MAAMD,EAAWzG,EAAKqB,SAASqF,GAAO1D,GAEtC,GAAe,MAAZyD,GAAoBL,IAAmBK,EAASJ,SAM/C,MAJAE,EAAcrE,KAAKuE,GAOvBC,IAGDH,EAAcxF,OAAS,GAEtBmD,EAAahC,QAAQqE,GAGtBD,EAAcvF,OAAS,GAEtBmD,EAAahC,QAAQoE,IAGtBC,EAAcxF,OAAS,GAAKuF,EAAcvF,OAAS,IAElDmD,EAAahC,KAAKoB,KAInBY,EAGX,YAAYyC,GAER,IAAI,IAAI5D,EAAI,EAAGA,EAA0B,EAAtB9C,KAAKoC,eAAoBU,IAExC,IAAI,IAAIC,EAAI,EAAGA,EAAI/C,KAAKmC,cAAeY,IAEnC2D,EAAS1G,KAAKoB,SAAS0B,GAAGC,GAAIA,EAAGD,GAK7C,oBAAoB4D,GAEhB,IAAI,IAAI5D,EAAI9C,KAAKoC,eAAgBU,EAA0B,EAAtB9C,KAAKoC,eAAoBU,IAE1D,IAAI,IAAIC,EAAI,EAAGA,EAAI/C,KAAKmC,cAAeY,IAEnC2D,EAAS1G,KAAKoB,SAAS0B,GAAGC,GAAIA,EAAGD,GAK7C,WAAWsD,EAAUrD,EAAGD,GAEpB,OAAO,ICrUA,MAEX,YAAYsD,EAAUrD,EAAGD,EAAGwC,EAAWE,EAAWhD,GAE9CxC,KAAKoG,SAAWA,EAChBpG,KAAK+C,EAAIA,EACT/C,KAAK8C,EAAIA,EACT9C,KAAKsF,UAAYA,EACjBtF,KAAKwF,UAAYA,EACjBxF,KAAKwC,aAAeA,EACpBxC,KAAK2B,MAAQ,KACb3B,KAAKyE,MAAQC,EACb1E,KAAK2G,aAAc,EAGvB,OAAOzD,GAEHlD,KAAK2B,MAAQuB,EAAQjD,IAAI0B,MAAM3B,KAAK+C,EAAG/C,KAAK8C,EAAG9C,KAAKoG,SAASpF,UAC7DhB,KAAK2B,MAAMvB,iBACXJ,KAAK2B,MAAMtB,GAAG,cAAe,KAAQL,KAAKwC,aAAaU,EAASlD,QAGpE,WAEIA,KAAK2G,aAAc,EACnB3G,KAAK2B,MAAMiF,YAAY,UAG3B,aAEI5G,KAAK2G,aAAc,EACnB3G,KAAK2B,MAAMkF,YAGf,eAAe3D,EAASH,EAAGD,EAAGwC,EAAWE,GAErC,IAAIzF,EAAOC,KAEX,OAAO,IAAIuE,QAAQ,CAACuC,EAASC,KAEzBhH,EAAKgD,EAAIA,EACThD,EAAK+C,EAAIA,EACT/C,EAAKuF,UAAYA,EACjBvF,EAAKyF,UAAYA,EAEjBtC,EAAQ8D,OAAO/G,IAAI,CACfgH,QAASlH,EAAK4B,MACdoB,EAAGA,EACHD,EAAGA,EACHoE,KAAM,SACNC,SAAU,IACVC,WAAY,KAAQN,SAMhC,QAAQ5D,EAASC,GAEb,IAAIpD,EAAOC,KAEX,OAAO,IAAIuE,QAAQ,CAACuC,EAASC,KAEzB7D,EAAQ8D,OAAO/G,IAAI,CACfgH,QAASlH,EAAK4B,MACd0F,MAAO,EACPH,KAAM,SACNC,SAAU,IACVC,WAAY,KAERjE,EAAUmE,OAAOvH,EAAK4B,OACtB5B,EAAK4B,MAAM2C,UACXvE,EAAK0E,MAAQC,EACboC,WD4PIV,EAAUpG,KAAKuH,SAASxE,GAAI/C,KAAKwH,SAAS1E,GAAIC,EAAGD,EAAG9C,KAAKwC,cAG7E,YAAYU,EAASG,EAAMN,EAAGD,GAE1B,OAAOO,EAAKyC,eAAe5C,EAASlD,KAAKuH,SAASxE,GAAI/C,KAAKwH,SAAS1E,GAAIC,EAAGD,GAG/E,SAASC,GAEL,OAAO/C,KAAKsC,QAAWtC,KAAKqC,SAAWU,EAG3C,SAASD,GAEL,OAAO9C,KAAKuC,QAAWvC,KAAKqC,SAAWS,EAG3C,UAAUO,GAEN,OAAOrD,KAAKkG,WAAW7C,GAG3B,WAAWA,GAEP,OAAgB,MAARA,GAAkBA,EAAKmC,UAAaxF,KAAKoC,eAAiB,EAGtE,YAAYW,EAAGD,EAAG2E,GAEd,MAAMC,EAAa5E,EAAI,EAAK,KAAO9C,KAAKoB,SAAS0B,EAAI,GAAGC,GAClD4E,EAAa7E,EAAI/C,KAAKqC,eAAiB,IAAMpC,KAAKoB,SAAS0B,EAAI,GAAM,KAAO9C,KAAKoB,SAAS0B,EAAI,GAAGC,GAEjG6E,EAAY7E,EAAI,EAAK,KAAO/C,KAAKoB,SAAS0B,GAAGC,EAAI,GACjD8E,EAAa9E,EAAIhD,KAAKoC,cAAgB,EAAK,KAAOnC,KAAKoB,SAAS0B,GAAGC,EAAI,GAE7E,OAMWtC,EANRgH,GAAY5E,GAAgD,MAAb6E,GAAkC,MAAbC,GAAiC,MAAZC,GAAiC,MAAbC,EAMvFC,EAASC,OAAO1D,KAClB,OAAdqD,GAAsBrD,EAAEtD,OAAS2G,EAAUtB,SAASrF,MACvC,OAAb6G,GAAqBvD,EAAEtD,OAAS6G,EAASxB,SAASrF,OANlC,CAAC2G,EAAWC,EAAWC,EAAUC,GAAWE,OAAO1D,GAAU,MAALA,GAAW2D,IAAI3D,GAAKA,EAAE+B,aF5T1E,EAAG,EAAG,GAAI,GAAI,GAAIpG,KAAKwC,aAAcxC,KAAKyC,YAAazC,KAAKkB,OACzFlB,KAAKqB,aAAe,IIlDb,MAEX,YAAY0B,EAAGD,GAEX9C,KAAK+C,EAAIA,EACT/C,KAAK8C,EAAIA,EACT9C,KAAKiI,UAAY,KACjBjI,KAAKkI,UAAY,KACjBlI,KAAKiB,MAAQ,EAGjB,OAAOiC,GAEHlD,KAAKiI,UAAY/E,EAAQjD,IAAIC,KAAKF,KAAK+C,EAAG/C,KAAK8C,EAAG9C,KAAKiB,OACvDjB,KAAKkI,UAAYhF,EAAQjD,IAAIC,KAAKF,KAAK+C,EAAG/C,KAAK8C,EAAI,GAAI,IAG3D,YAAY7B,GAERjB,KAAKiB,MAAQA,EACbjB,KAAKiI,UAAUE,QAAQlH,GAG3B,YAAYf,GAERF,KAAKkI,UAAUC,QAAQjI,KJyBc,EAAG,GACxCF,KAAKsB,MAAQ,IKnDN,MAEX,YAAYyB,EAAGD,EAAGsF,GAEdpI,KAAK+C,EAAIA,EACT/C,KAAK8C,EAAIA,EACT9C,KAAKE,KAAO,KACZF,KAAKoI,QAAUA,EAGnB,OAAOlF,GAEHlD,KAAKE,KAAOgD,EAAQjD,IAAIC,KAAKF,KAAK+C,EAAG/C,KAAK8C,EAAG9C,KAAKiB,OAElDjB,KAAKqI,OACLnF,EAAQoF,KAAKC,SAAS,CAAEC,MAAO,IAAM9B,SAAU1G,KAAKqI,KAAMI,cAAezI,KAAM0I,MAAM,IAGzF,OAEI,GAAG1I,KAAKoI,SAAW,EAEf,OAGJpI,KAAKoI,UAGL,MAAMO,EAAUhI,KAAKC,MAAMZ,KAAKoI,QAAU,IAE1C,IAAIA,EAAWpI,KAAKoI,QAAU,GAC3BA,EAAU,KAETA,EAAU,IAAMA,GAGpBpI,KAAKE,KAAKiI,QAAQ,GAAGQ,KAAWP,OLeT,IAAK,EAAG,KAE/B,MACMQ,GADgB,IMnDf,MAEX,UAAUpI,GAEN,MAAMoI,EAAS,ICNR,MAEX,cAEI5I,KAAK6I,cAAgB,GACrB7I,KAAK8I,4BAA8B,SDGnC,OAAOtI,GAGH,KAAK,EAEDoI,EAAOC,cAAgB,CACnB,wCACA,0CACA,+EACA,yEAGJD,EAAOE,4BAA+BlH,IAElC,GAAyB,IAAtBA,EAAKH,aAEJ,MAAO,CACH,yBACA,0EACA,wCAMZ,MAGJ,KAAK,EAEDmH,EAAOC,cAAgB,CACnB,0BACA,iCACA,qEACA,+CAGJ,MAGJ,KAAK,EAEDD,EAAOC,cAAgB,CACnB,8BACA,2EASJ,MAGJ,KAAK,EAEDD,EAAOC,cAAgB,CACnB,qDACA,gDACA,kFACA,8DACA,8EACA,2CACA,+BAGJ,MAGJ,KAAK,EAEDD,EAAOC,cAAgB,CACnB,2BACA,yEACA,+DACA,kBACA,oEACA,yEAGJ,MAGJ,KAAK,EAEDD,EAAOC,cAAgB,CACnB,kDACA,oCACA,6CACA,kDACA,iCAGJ,MAGJ,KAAK,EAEDD,EAAOC,cAAgB,CACnB,8CACA,kCACA,6DACA,kFAGJ,MAGJ,KAAK,EAEDD,EAAOC,cAAgB,CACnB,yDACA,gDACA,4BACA,4CACA,4CACA,8DACA,gCACA,qCAGJ,MAGJ,KAAK,EAEDD,EAAOC,cAAgB,CACnB,oBACA,uCACA,+DACA,gDACA,+BACA,yBACA,+DAOZ,OAAOD,KNhGsBG,UAAU/I,KAAKQ,OAC5CR,KAAKuB,MAAQ,IQvDN,MAEX,YAAYwB,EAAGD,EAAG8F,GAEd5I,KAAK+C,EAAIA,EACT/C,KAAK8C,EAAIA,EACT9C,KAAK4I,OAASA,EAEd5I,KAAKgJ,aAAe,KACpBhJ,KAAKiJ,iBAAmB,EACxBjJ,KAAKkJ,eAAiB,KAG1B,OAAOhG,GAEH,MAAMnD,EAAOC,KASPmJ,EAAuBjG,EAAQjD,IAAIwD,SAAS,CAAEC,UAAW,CAAE0F,MAAO,YAClEC,EAAe,IAAIxF,OAAOyF,KAAKC,UAAUvJ,KAAK+C,EAAG/C,KAAK8C,EARlC,IACC,KAQ3BqG,EAAqBK,cAAcH,GAEnCnG,EAAQuG,MAAMpJ,GAAG,cAAgBqJ,IAC1BL,EAAaM,SAASD,EAAQ3G,EAAG2G,EAAQ5G,KAExC/C,EAAKiJ,aAAaY,QAAS,KAKnC5J,KAAK6J,iBAAmB3G,EAAQjD,IAAIC,KAAKF,KAAK+C,EAAI,EAAG/C,KAAK8C,EAAI,EAAG,GAAI,CAAEsG,MAAO,SAG9E,MAAMU,EAAoB5G,EAAQjD,IAAIwD,SAAS,CAAEC,UAAW,CAAE0F,MAAO,YAC/DW,EAAY,IAAIlG,OAAOyF,KAAKC,UAC9BvJ,KAAK+C,EAxBiB,IAGH,IAsBnB/C,KAAK8C,EAxBkB,IAwBO,GAtBX,IACC,KAwBxBgH,EAAkBN,cAAcO,GAEhChK,EAAKiK,cAAc9G,EAASlD,KAAK4I,OAAOC,eAG5C,cAAc3F,EAAS+G,GAEnB,IAAIA,EAEA,OAGJ,MAAMlK,EAAOC,KAEc,OAAxBD,EAAKmJ,iBAEJnJ,EAAKmJ,eAAiB,IAG1BnJ,EAAKmJ,eAAejH,QAAQgI,GAEJ,MAArBlK,EAAKiJ,eAKRjJ,EAAKiJ,aAAe9F,EAAQoF,KAAKC,SAAS,CACtCC,MAAO,GACP9B,SAAU,KACN,GAAkC,IAA/B3G,EAAKmJ,eAAepI,OAKnB,OAHAf,EAAKiJ,aAAa1B,SAClBvH,EAAKiJ,aAAe,UACpBlC,UAIJ/G,EAAKkJ,mBAEL,MAAMiB,EAAcnK,EAAKmJ,eAAe,GAExC,GAAGnJ,EAAKkJ,iBAAmBiB,EAAYpJ,OAKnC,OAHAf,EAAKkJ,iBAAmB,EACxBlJ,EAAKmJ,eAAenH,aACpBhC,EAAKiJ,aAAaY,QAAS,GAI/B,MAAMO,EAAUD,EAAYE,MAAM,EAAGrK,EAAKkJ,kBAC1ClJ,EAAK8J,iBAAiB1B,QAAQgC,IAElC1B,cAAezI,KACf0I,MAAM,KAId,wBAAwBxF,EAAStB,GAE7B,MAAMqI,EAAWjK,KAAK4I,OAAOE,4BAA4BlH,GACzD5B,KAAKgK,cAAc9G,EAAS+G,KRlDL,IAAK,IAAKrB,GAEjC5I,KAAKoB,SAASkC,OAAOtD,MACrBA,KAAKqB,aAAaiC,OAAOtD,MACzBA,KAAKsB,MAAMgC,OAAOtD,MAClBA,KAAKuB,MAAM+B,OAAOtD,MAGtB,SAGOA,KAAKsB,MAAM8G,SAAW,EAErBpI,KAAKM,MAAMC,MAAM,gBAAiB,CAAEU,MAAOjB,KAAKiB,QAKjDjB,KAAKkB,MAAMmJ,oBAMXrK,KAAKkB,MAAMoJ,aAEVtK,KAAKkB,MAAMqJ,OAKfvK,KAAKoB,SAASoJ,OAAOxK,OAGzB,aAAakD,EAASG,GAGlB,IAAGH,EAAQhC,MAAMmJ,mBAMbnH,EAAQ9B,SAASqJ,UAAUpH,GAA/B,CAMA,GAAGA,EAAKsD,YAIJ,OAFAzD,EAAQ/B,cAAgB,QACxBkC,EAAKqH,aAIT,GAAoC,IAAjCxH,EAAQ/B,cAAcL,OAIrB,OAFAoC,EAAQ/B,cAAcc,KAAKoB,QAC3BA,EAAKsH,WAIT,GAAoC,IAAjCzH,EAAQ/B,cAAcL,OACzB,CACI,MAAM8J,EAAe1H,EAAQ/B,cAAc,GACrC0J,EAAQlK,KAAKmK,IAAIF,EAAatF,UAAYjC,EAAKiC,WAC/CyF,EAAQpK,KAAKmK,IAAIF,EAAapF,UAAYnC,EAAKmC,WAErD,GAAc,IAAVqF,GAAyB,IAAVE,GAA2B,IAAVF,GAAyB,IAAVE,EACnD,CACI7H,EAAQ/B,cAAcc,KAAKoB,GAE3B,IAAI2H,EAAoB9H,EAAQ/B,cAAc,GAC1C8J,EAAqB/H,EAAQ/B,cAAc,GAE/C+B,EAAQ9B,SAAS8J,UAAUhI,EAAS8H,EAAmBC,GAEvD/H,EAAQhC,MAAMe,KAAK,KAIViB,EAAQ9B,SAAS+J,WAAWH,EAAkB1F,UAAW0F,EAAkBxF,YAC3EtC,EAAQ9B,SAAS+J,WAAWF,EAAmB3F,UAAW2F,EAAmBzF,YAG9EtC,EAAQ9B,SAAS8J,UAAUhI,EAAS8H,EAAmBC,GAGpD1G,QAAQuC,YAInB5D,EAAQ/B,cAAciD,QAASf,IAAWA,EAAKqH,eAC/CxH,EAAQ/B,cAAgB,GAExB+B,EAAQ1B,WAAa,KAKjC,YAAY0B,EAASe,GAEjBf,EAAQ1B,aACR0B,EAAQzB,eAERyB,EAAQjC,OAAU,GAAKiC,EAAQ1B,WAC/B0B,EAAQ7B,aAAa+J,YAAYlI,EAAQjC,OAEzCiC,EAAQ3B,MAAM8J,wBAAwBnI,EAAS,CAC3C1B,WAAY0B,EAAQ1B,WACpBC,aAAcyB,EAAQzB,eAGvByB,EAAQ1B,WAAa,EAEpB0B,EAAQ7B,aAAaiK,YAAY,GAAGpI,EAAQ1B,2BAI5C0B,EAAQ7B,aAAaiK,YAAY,MS/K9B,6BAEX,cAEIxL,MAAM,iBAENE,KAAKuL,WAAa,EAGtB,KAAK3J,GAED5B,KAAKuL,WAAa3J,EAAKX,MAG3B,SAEI,MAAMlB,EAAOC,KAGbA,KAAKC,IAAIC,KAAK,GAAI,GAAI,cAGtBF,KAAKC,IAAIC,KAAK,GAAI,IAAK,gBAAgBF,KAAKuL,cAG5C,MAAMC,EAAexL,KAAKC,IAAIC,KAAK,GAAI,IAAK,uBAC5CsL,EAAapL,iBACboL,EAAanL,GAAG,cAAe,KAAQN,EAAKO,MAAMC,MAAM,kBCvBhE,MAAMkL,EAAS,CACXC,KAAM7H,OAAO8H,KACbC,MAAO,IACPC,OAAQ,KACRvL,MAAO,CAACwL,EAAYC,EAAYC,IAGvB,IAAInI,OAAOoI,KAAKR","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default class extends Phaser.Scene {\r\n\r\n    constructor()\r\n    {\r\n        super('TitleScene');\r\n    }\r\n\r\n    create()\r\n    {\r\n        const self = this;\r\n\r\n        // Title\r\n        this.add.text(50, 50, 'Match Three!');\r\n\r\n        // \"Start\" Button\r\n        const startBtn = this.add.text(50, 70, 'Start Game');\r\n        startBtn.setInteractive();\r\n        startBtn.on('pointerdown', () => { self.scene.start('RoundScene', { level: 0 }); });\r\n    }\r\n    \r\n}","// Source: https://stackoverflow.com/questions/5915096/get-random-item-from-javascript-array\r\nconst getRandomItem = (items) => {\r\n    return items[Math.floor(Math.random() * items.length)];\r\n}\r\n\r\nexport {\r\n    getRandomItem\r\n}","export default {\r\n    Active: 0,\r\n    Destroyed: 1\r\n};","export default {\r\n    None: 0,\r\n    EasyWin: 1\r\n};","export default [\r\n    { name: 'Blue', imageKey: 'tile_01' },\r\n    { name: 'Green', imageKey: 'tile_02' },\r\n    { name: 'Red', imageKey: 'tile_03' },\r\n    { name: 'Yellow', imageKey: 'tile_04' }\r\n];","import ActionQueue from '../ActionQueue';\r\nimport DialogManager from '../DialogManager';\r\nimport Guide from '../Guide';\r\nimport ScoreDisplay from '../ScoreDisplay';\r\nimport TileGrid from '../TileGrid';\r\nimport Timer from '../Timer';\r\n\r\nexport default class extends Phaser.Scene {\r\n\r\n    constructor()\r\n    {\r\n        super('RoundScene');\r\n\r\n        this.score = null;\r\n        this.queue = null;\r\n        this.selectedTiles = null;\r\n        this.tileGrid = null;\r\n        this.scoreDisplay = null;\r\n        this.timer = null;\r\n \r\n        this.guide = null;\r\n        this.level = null;\r\n\r\n        this.comboCount = null;\r\n        this.totalMatches = null;\r\n    }\r\n\r\n    preload()\r\n    {\r\n        this.load.image('tile_01', 'assets/tile_01.png');\r\n        this.load.image('tile_02', 'assets/tile_02.png');\r\n        this.load.image('tile_03', 'assets/tile_03.png');\r\n        this.load.image('tile_04', 'assets/tile_04.png');\r\n    }\r\n\r\n    init(data)\r\n    {\r\n        this.level = data.level;\r\n    }\r\n\r\n    create()\r\n    {\r\n        this.score = 0;\r\n        this.comboCount = 0;\r\n        this.totalMatches = 0;\r\n\r\n        this.queue = new ActionQueue();\r\n\r\n        this.selectedTiles = [];\r\n        this.tileGrid = new TileGrid(6, 6, 50, 50, 50, this.onTileSelect, this.onTileMatch, this.queue);\r\n        this.scoreDisplay = new ScoreDisplay(5, 5);\r\n        this.timer = new Timer(500, 5, 300);\r\n\r\n        const dialogManager = new DialogManager();\r\n        const script = dialogManager.getScript(this.level);\r\n        this.guide = new Guide(100, 100, script);\r\n\r\n        this.tileGrid.create(this);\r\n        this.scoreDisplay.create(this);\r\n        this.timer.create(this);\r\n        this.guide.create(this);\r\n    }\r\n\r\n    update()\r\n    {\r\n        // Have we run out of time?\r\n        if(this.timer.seconds <= 0)\r\n        {\r\n            this.scene.start('GameOverScene', { score: this.score });\r\n            return;\r\n        }\r\n\r\n        // Are we currently executing a queued action?\r\n        if(this.queue.isActionRunning())\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Do we have any queued actions on the stack?\r\n        if(this.queue.hasActions())\r\n        {\r\n            this.queue.next();\r\n            return;\r\n        }\r\n\r\n        // If nothing's left in the queue, we can move the game's state forward\r\n        this.tileGrid.update(this);\r\n    }\r\n\r\n    onTileSelect(context, tile)\r\n    {\r\n        // Are we currently executing a queued action?\r\n        if(context.queue.isActionRunning())\r\n        {\r\n            return;\r\n        }\r\n    \r\n        // Can we select this tile?\r\n        if(!context.tileGrid.canSelect(tile))\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Is this tile already selected?\r\n        if(tile.isActivated)\r\n        {\r\n            context.selectedTiles = [];\r\n            tile.deactivate();\r\n            return;\r\n        }\r\n    \r\n        if(context.selectedTiles.length === 0)\r\n        {\r\n            context.selectedTiles.push(tile);\r\n            tile.activate();\r\n            return;\r\n        }\r\n    \r\n        if(context.selectedTiles.length === 1)\r\n        {\r\n            const selectedTile = context.selectedTiles[0];\r\n            const xDiff = Math.abs(selectedTile.tileGridX - tile.tileGridX);\r\n            const yDiff = Math.abs(selectedTile.tileGridY - tile.tileGridY);\r\n    \r\n            if((xDiff === 1 && yDiff === 0) || (xDiff === 0 && yDiff === 1))\r\n            {\r\n                context.selectedTiles.push(tile);\r\n    \r\n                let firstSelectedTile = context.selectedTiles[0];\r\n                let secondSelectedTile = context.selectedTiles[1];\r\n    \r\n                context.tileGrid.swapTiles(context, firstSelectedTile, secondSelectedTile);\r\n    \r\n                context.queue.push(() => {\r\n    \r\n                    // If there are no matches, swap the tiles back\r\n                    if(\r\n                        !context.tileGrid.hasMatches(firstSelectedTile.tileGridX, firstSelectedTile.tileGridY) &&\r\n                        !context.tileGrid.hasMatches(secondSelectedTile.tileGridX, secondSelectedTile.tileGridY)\r\n                    )\r\n                    {\r\n                        context.tileGrid.swapTiles(context, firstSelectedTile, secondSelectedTile);\r\n                    }\r\n    \r\n                    return Promise.resolve();\r\n    \r\n                });\r\n    \r\n                context.selectedTiles.forEach((tile) => { tile.deactivate(); });\r\n                context.selectedTiles = [];\r\n                \r\n                context.comboCount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    onTileMatch(context, matchedTiles)\r\n    {\r\n        context.comboCount++;\r\n        context.totalMatches++;\r\n\r\n        context.score += (10 * context.comboCount);\r\n        context.scoreDisplay.updateScore(context.score);\r\n\r\n        context.guide.displayTileMatchMessage(context, {\r\n            comboCount: context.comboCount,\r\n            totalMatches: context.totalMatches\r\n        });\r\n\r\n        if(context.comboCount > 1)\r\n        {\r\n            context.scoreDisplay.updateCombo(`${context.comboCount}x multiplier!`);\r\n        }\r\n        else\r\n        {\r\n            context.scoreDisplay.updateCombo('');\r\n        }\r\n    }\r\n    \r\n}","export default class {\r\n\r\n    constructor()\r\n    {\r\n        this.queuedActions = [];\r\n        this.currentAction = null;\r\n    }\r\n\r\n    isActionRunning()\r\n    {\r\n        return this.currentAction != null;\r\n    }\r\n\r\n    hasActions()\r\n    {\r\n        return this.queuedActions.length > 0;\r\n    }\r\n\r\n    next()\r\n    {\r\n        this.currentAction = this.queuedActions.shift();\r\n        this.currentAction();\r\n    }\r\n\r\n    push(action)\r\n    {\r\n        var self = this;\r\n        self.queuedActions.push(() => { action().then(() => { self.currentAction = null; }) });\r\n    }\r\n\r\n}","import { getRandomItem } from './Utility';\r\nimport Tile from './Tile';\r\nimport TileGenerationBehavior from './TileGenerationBehavior';\r\nimport TileState from './TileState';\r\nimport TileType from './TileType';\r\n\r\nexport default class {\r\n\r\n    constructor(tileGridWidth, tileGridHeight, tileSize, offsetX, offsetY, onTileSelect, onTileMatch, queue)\r\n    {\r\n        this.offsetX = offsetX;\r\n        this.offsetY = offsetY;\r\n        this.tileSize = tileSize;\r\n        this.tileGridHeight = tileGridHeight;\r\n        this.tileGridWidth = tileGridWidth;\r\n        this.tileGrid = [];\r\n        this.tileImageContainer = null;\r\n        this.playAreaOffset = (this.tileGridHeight * this.tileSize);\r\n\r\n        this.onTileSelect = onTileSelect;\r\n        this.onTileMatch = onTileMatch;\r\n\r\n        this.tileGenerationBehavior = TileGenerationBehavior.None;\r\n\r\n        this.queue = queue;\r\n\r\n        // We're going to generate a grid that's twice the height of\r\n        // the desired tile grid height since we'll use the hidden, upper\r\n        // region to stage the bricks that will fall into the play area\r\n        for(let y = 0; y < tileGridHeight * 2; y++)\r\n        {\r\n            this.tileGrid[y] = [];\r\n            for(let x = 0; x < tileGridWidth; x++)\r\n            {\r\n                this.tileGrid[y][x] = (y < tileGridHeight)\r\n                    ? null\r\n                    : this.createTile(this.getTileType(x, y, this.tileGenerationBehavior), x, y);\r\n            }\r\n        }\r\n    }\r\n\r\n    create(context)\r\n    {\r\n        this.tileImageContainer = context.add.container();\r\n\r\n        // Create all of the tiles\r\n        this.forEachTile(tile => {\r\n\r\n            if(tile === null)\r\n            {\r\n                return;\r\n            }\r\n\r\n            tile.create(context);\r\n            this.tileImageContainer.add(tile.image);\r\n\r\n        });\r\n\r\n        // Create a mask to only show the play area\r\n        const maskShape = context.make.graphics();\r\n        maskShape.fillStyle(0xffffff, 1);\r\n        maskShape.fillRect(this.offsetX/2, this.offsetY/2 + (this.tileGridHeight * this.tileSize), this.tileGridWidth * this.tileSize, this.tileGridHeight * this.tileSize);\r\n        \r\n        this.tileImageContainer.mask = new Phaser.Display.Masks.GeometryMask(context, maskShape);\r\n    }\r\n\r\n    update(context)\r\n    {\r\n        const self = this;\r\n\r\n        if(self.queue.length > 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Detect and destroy any matches\r\n        const matchedTiles = self.getMatches();\r\n\r\n        if(matchedTiles.length > 0)\r\n        {\r\n            self.onTileMatch(context, matchedTiles);\r\n        }\r\n\r\n        let destroys = [];\r\n        matchedTiles.forEach(t => { destroys.push(t.destroy(context, this.tileImageContainer)); });\r\n\r\n        if(destroys.length > 0)\r\n        {\r\n            self.queue.push(() => { return Promise.all(destroys); });\r\n        }\r\n\r\n        // Remove any destroyed tiles\r\n        self.forEachTile((tile, x, y) => {\r\n\r\n            if(tile === null)\r\n            {\r\n                return;\r\n            }\r\n\r\n            if(tile.state === TileState.Destroyed)\r\n            {\r\n                self.tileGrid[y][x] = null;\r\n            }\r\n\r\n        });\r\n\r\n        // Shift all of the tiles downward to fill empty spots\r\n        let drops = [];\r\n        for(let x = 0; x < this.tileGridWidth; x++)\r\n        {\r\n            let y = (this.tileGridHeight * 2) - 1;\r\n            while(y >= 0)\r\n            {\r\n                // If the tile is null...\r\n                if(self.tileGrid[y][x] === null)\r\n                {\r\n                    // ...find the closest tile that's not null...\r\n                    let closestY = y - 1;\r\n                    while(closestY >= 0)\r\n                    {\r\n                        let closestTile = self.tileGrid[closestY][x];\r\n                        if(closestTile !== null)\r\n                        {\r\n                            // ...and shift it downward\r\n                            self.tileGrid[y][x] = closestTile;\r\n                            self.tileGrid[closestY][x] = null;\r\n                            drops.push(this.getTileDrop(context, closestTile, x, y));\r\n                            y--;\r\n                        }\r\n                        closestY--;\r\n                    }\r\n                }\r\n\r\n                y--;\r\n            }\r\n        }\r\n\r\n        // Fill in all of the empty tiles\r\n        self.forEachPlayableTile((tile, x, y) => {\r\n            if(tile === null)\r\n            {\r\n                const adjustedY = y - self.tileGridHeight;\r\n\r\n                const tile = self.createTile(self.getTileType(x, y, self.tileGenerationBehavior), x, adjustedY);\r\n                self.tileGrid[adjustedY][x] = tile;\r\n                tile.create(context);\r\n                self.tileImageContainer.add(tile.image);\r\n            }\r\n        });\r\n\r\n        if(drops.length > 0)\r\n        {\r\n            self.queue.push(() => { return Promise.all(drops); });\r\n        }\r\n    }\r\n\r\n    swapTiles(context, firstTile, secondTile)\r\n    {\r\n        let self = this;\r\n\r\n        self.queue.push(() => {\r\n            \r\n            let firstTileX = firstTile.x;\r\n            let firstTileY = firstTile.y;\r\n            let firstTileGridX = firstTile.tileGridX;\r\n            let firstTileGridY = firstTile.tileGridY;\r\n    \r\n            let secondTileX = secondTile.x;\r\n            let secondTileY = secondTile.y;\r\n            let secondTileGridX = secondTile.tileGridX;\r\n            let secondTileGridY = secondTile.tileGridY;\r\n    \r\n            let firstSwap = secondTile.updatePosition(context, firstTileX, firstTileY, firstTileGridX, firstTileGridY);\r\n            self.tileGrid[firstTileGridY][firstTileGridX] = secondTile;\r\n    \r\n            let secondSwap = firstTile.updatePosition(context, secondTileX, secondTileY, secondTileGridX, secondTileGridY);\r\n            self.tileGrid[secondTileGridY][secondTileGridX] = firstTile;\r\n\r\n            return Promise.all([firstSwap, secondSwap]);\r\n\r\n        });\r\n    }\r\n\r\n    hasMatches(targetGridX, targetGridY)\r\n    {\r\n        return this.getMatches(targetGridX, targetGridY).length > 0;\r\n    }\r\n\r\n    getMatches(targetGridX, targetGridY)\r\n    {\r\n        const self = this;\r\n        const matchedTiles = [];\r\n\r\n        self.forEachTile((tile, x, y) => {\r\n\r\n            if(\r\n                (typeof targetGridX !== 'undefined' && x !== targetGridX) &&\r\n                (typeof targetGridY !== 'undefined' && y !== targetGridY)\r\n              )\r\n            {\r\n                return;\r\n            }\r\n\r\n            if(!this.isPlayable(tile))\r\n            {\r\n                return;\r\n            }\r\n\r\n            const targetTileType = tile.tileType;\r\n            const matchedXTiles = [];\r\n            const matchedYTiles = [];\r\n\r\n            // Check for matches to the right\r\n            let currX = (x + 1);\r\n            while(currX < self.tileGridWidth)\r\n            {\r\n                const currTile = self.tileGrid[y][currX];\r\n\r\n                if(currTile != null && targetTileType.name === currTile.tileType.name)\r\n                {\r\n                    matchedXTiles.push(currTile);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n\r\n                currX++;\r\n            }\r\n\r\n            // Check for matches to the left\r\n            currX = (x - 1);\r\n            while(currX > 0)\r\n            {\r\n                const currTile = self.tileGrid[y][currX];\r\n\r\n                if(currTile != null && targetTileType.name === currTile.tileType.name)\r\n                {\r\n                    matchedXTiles.push(currTile);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n\r\n                currX--;\r\n            }\r\n\r\n            // Check matches downwards\r\n            let currY = (y + 1);\r\n            while(currY < self.tileGridHeight)\r\n            {\r\n                const currTile = self.tileGrid[currY][x];\r\n\r\n                if(currTile != null && targetTileType.name === currTile.tileType.name)\r\n                {\r\n                    matchedYTiles.push(currTile);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n\r\n                currY++;\r\n            }\r\n\r\n            // Check matches upwards\r\n            currY = (y - 1);\r\n            while(currY > 0)\r\n            {\r\n                const currTile = self.tileGrid[currY][x];\r\n\r\n                if(currTile != null && targetTileType === currTile.tileType)\r\n                {\r\n                    matchedYTiles.push(currTile);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n\r\n                currY--;\r\n            }\r\n            \r\n            if(matchedYTiles.length > 1)\r\n            {\r\n                matchedTiles.push(...matchedYTiles);\r\n            }\r\n            \r\n            if(matchedXTiles.length > 1)\r\n            {\r\n                matchedTiles.push(...matchedXTiles);\r\n            }\r\n\r\n            if(matchedYTiles.length > 1 || matchedXTiles.length > 1)\r\n            {\r\n                matchedTiles.push(tile);\r\n            }\r\n        });\r\n\r\n        return matchedTiles;\r\n    }\r\n\r\n    forEachTile(callback)\r\n    {\r\n        for(let y = 0; y < this.tileGridHeight * 2; y++)\r\n        {\r\n            for(let x = 0; x < this.tileGridWidth; x++)\r\n            {\r\n                callback(this.tileGrid[y][x], x, y);\r\n            }\r\n        }\r\n    }\r\n\r\n    forEachPlayableTile(callback)\r\n    {\r\n        for(let y = this.tileGridHeight; y < this.tileGridHeight * 2; y++)\r\n        {\r\n            for(let x = 0; x < this.tileGridWidth; x++)\r\n            {\r\n                callback(this.tileGrid[y][x], x, y);\r\n            }\r\n        }\r\n    }\r\n\r\n    createTile(tileType, x, y)\r\n    {\r\n        return new Tile(tileType, this.getTileX(x), this.getTileY(y), x, y, this.onTileSelect);\r\n    }\r\n\r\n    getTileDrop(context, tile, x, y)\r\n    {\r\n        return tile.updatePosition(context, this.getTileX(x), this.getTileY(y), x, y);\r\n    }\r\n\r\n    getTileX(x)\r\n    {\r\n        return this.offsetX + (this.tileSize * x);\r\n    }\r\n\r\n    getTileY(y)\r\n    {\r\n        return this.offsetY + (this.tileSize * y);\r\n    }\r\n\r\n    canSelect(tile)\r\n    {\r\n        return this.isPlayable(tile);\r\n    }\r\n\r\n    isPlayable(tile)\r\n    {\r\n        return (tile != null) && (tile.tileGridY > (this.tileGridHeight - 1));\r\n    }\r\n\r\n    getTileType(x, y, behavior)\r\n    {\r\n        const aboveTile = (y < 1) ? null : this.tileGrid[y - 1][x];\r\n        const belowTile = (y > self.tileGridHeight - 1 || !this.tileGrid[y + 1]) ? null : this.tileGrid[y + 1][x];\r\n\r\n        const leftTile = (x < 1) ? null : this.tileGrid[y][x - 1];\r\n        const rightTile = (x > self.tileGridWidth - 1) ? null : this.tileGrid[y][x + 1];\r\n\r\n        if(behavior == TileGenerationBehavior.EasyWin && (aboveTile != null || belowTile != null || leftTile != null || rightTile != null))\r\n        {\r\n            return getRandomItem([aboveTile, belowTile, leftTile, rightTile].filter(t => t != null).map(t => t.tileType));\r\n        }\r\n        else\r\n        {\r\n            return getRandomItem(TileType.filter(t =>\r\n                (aboveTile === null || t.name !== aboveTile.tileType.name) &&\r\n                (leftTile === null || t.name !== leftTile.tileType.name)\r\n            ));\r\n        }\r\n    }\r\n}","import TileState from './TileState';\r\n\r\nexport default class {\r\n\r\n    constructor(tileType, x, y, tileGridX, tileGridY, onTileSelect)\r\n    {\r\n        this.tileType = tileType;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.tileGridX = tileGridX;\r\n        this.tileGridY = tileGridY;\r\n        this.onTileSelect = onTileSelect;\r\n        this.image = null;\r\n        this.state = TileState.Active;\r\n        this.isActivated = false;\r\n    }\r\n\r\n    create(context)\r\n    {\r\n        this.image = context.add.image(this.x, this.y, this.tileType.imageKey);\r\n        this.image.setInteractive();\r\n        this.image.on('pointerdown', () => { this.onTileSelect(context, this); });\r\n    }\r\n\r\n    activate()\r\n    {\r\n        this.isActivated = true;\r\n        this.image.setTintFill(0xffffff);\r\n    }\r\n\r\n    deactivate()\r\n    {\r\n        this.isActivated = false;\r\n        this.image.clearTint();\r\n    }\r\n\r\n    updatePosition(context, x, y, tileGridX, tileGridY)\r\n    {\r\n        let self = this;\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            self.x = x;\r\n            self.y = y;\r\n            self.tileGridX = tileGridX;\r\n            self.tileGridY = tileGridY;\r\n\r\n            context.tweens.add({\r\n                targets: self.image,\r\n                x: x,\r\n                y: y,\r\n                ease: 'Power1',\r\n                duration: 500,\r\n                onComplete: () => { resolve() }\r\n            });\r\n\r\n        });\r\n    }\r\n\r\n    destroy(context, container)\r\n    {\r\n        let self = this;\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            context.tweens.add({\r\n                targets: self.image,\r\n                alpha: 0,\r\n                ease: 'Power1',\r\n                duration: 500,\r\n                onComplete: () => {\r\n\r\n                    container.remove(self.image);\r\n                    self.image.destroy();\r\n                    self.state = TileState.Destroyed;\r\n                    resolve();\r\n\r\n                }\r\n            });\r\n\r\n        });\r\n    }\r\n}","export default class {\r\n\r\n    constructor(x, y)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.scoreText = null;\r\n        this.comboText = null;\r\n        this.score = 0;\r\n    }\r\n\r\n    create(context)\r\n    {\r\n        this.scoreText = context.add.text(this.x, this.y, this.score);\r\n        this.comboText = context.add.text(this.x, this.y + 20, '');\r\n    }\r\n\r\n    updateScore(score)\r\n    {\r\n        this.score = score;\r\n        this.scoreText.setText(score);\r\n    }\r\n\r\n    updateCombo(text)\r\n    {\r\n        this.comboText.setText(text);\r\n    }\r\n}","export default class {\r\n\r\n    constructor(x, y, seconds)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.text = null;\r\n        this.seconds = seconds;\r\n    }\r\n\r\n    create(context)\r\n    {\r\n        this.text = context.add.text(this.x, this.y, this.score);\r\n        \r\n        this.tick();\r\n        context.time.addEvent({ delay: 1000, callback: this.tick, callbackScope: this, loop: true })\r\n    }\r\n\r\n    tick()\r\n    {\r\n        if(this.seconds <= 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.seconds--;\r\n\r\n        // Display the remaining time\r\n        const minutes = Math.floor(this.seconds / 60);\r\n\r\n        let seconds = (this.seconds % 60);\r\n        if(seconds < 10)\r\n        {\r\n            seconds = '0' + seconds;\r\n        }\r\n\r\n        this.text.setText(`${minutes}:${seconds}`);\r\n    }\r\n}","import DialogScript from \"./DialogScript\";\r\n\r\nexport default class {\r\n\r\n    getScript(level)\r\n    {\r\n        const script = new DialogScript();\r\n\r\n        switch(level)\r\n        {\r\n            // Level 0 (Intro)\r\n            case 0:\r\n\r\n                script.introMessages = [\r\n                    \"Oh, doozle, you made it! You're here!\",\r\n                    \"We need your help collecting dew drops!\",\r\n                    \"If you match three or more dew drops of the same color, we can collect them!\",\r\n                    \"To make a match, click on one or more dew drops to swap their places!\"\r\n                ];\r\n\r\n                script.getDisplayTileMatchMessages = (data) => {\r\n\r\n                    if(data.totalMatches === 1)\r\n                    {\r\n                        return [\r\n                            \"You got it! That's it!\",\r\n                            \"You collect extra dew drops when you chain together matches in a combo!\",\r\n                            \"See if you can collect X dew drops!\"\r\n                        ];\r\n                    }\r\n\r\n                };\r\n\r\n                break;\r\n\r\n            // Level 1 (Timer Intro)\r\n            case 1:\r\n\r\n                script.introMessages = [\r\n                    \"You're so good at this!\",\r\n                    \"We'll have to hurry this time!\",\r\n                    \"We only have one minute before the sun dries up all the dew drops!\",\r\n                    \"Collect at least X dew drops in one minute!\"\r\n                ];\r\n\r\n                break;\r\n\r\n            // Level 2 (Breaking the Fourth Wall)\r\n            case 2:\r\n\r\n                script.introMessages = [\r\n                    \"Wow, we're so proud of you!\",\r\n                    \"This round you'll only have 30 seconds to collect at least X dew drops!\"\r\n                ];\r\n\r\n                // \"Wait, wait, sorry, hold on.\"\r\n                // \"It's too early for the \\\"Lose in a Panic\\\" scenario.\"\r\n                // \"So sorry about that.\"\r\n                // \"You've been really great so far, honestly.\"\r\n                // \"You know, what, let's just go to the next round and we'll take it from the top.\"\r\n\r\n                break;\r\n\r\n            // Level 3 (Easy Win)\r\n            case 3:\r\n\r\n                script.introMessages = [\r\n                    \"Alright, I think we've got everything figured out.\",\r\n                    \"Okay, for this next round, let me set you up:\",\r\n                    \"Remember, you've been winnig the last few rounds and you're gaining confidence.\",\r\n                    \"In this round, it's going to be easy for you to get combos.\",\r\n                    \"So the idea here is that you're going to get a little too confident, right?\",\r\n                    \"Like a little full of yourself, alright?\",\r\n                    \"Okay, great! Let's do this:\"\r\n                ];\r\n\r\n                break;\r\n\r\n            // Level 4 (Losing Confidence)\r\n            case 4:\r\n\r\n                script.introMessages = [\r\n                    \"Okay, okay, great stuff.\",\r\n                    \"For this round, you're bringing all of that pride, all of that hubris.\",\r\n                    \"And, when the round starts, things are still going your way.\",\r\n                    \"But guess what?\",\r\n                    \"Halfway through this round, things start getting a little harder.\",\r\n                    \"This is where we to start your chip away at your pride as the player.\"\r\n                ];\r\n\r\n                break;\r\n\r\n            // Level 5 (Fall From Grace)\r\n            case 5:\r\n\r\n                script.introMessages = [\r\n                    \"Wow, really moving work. It feels so authentic.\",\r\n                    \"It's been a joy working with you.\",\r\n                    \"Okay, here we go, this is a pivotal scene:\",\r\n                    \"This round will not go your way at all. At all.\",\r\n                    \"This is your fall from grace.\",\r\n                ];\r\n\r\n                break;\r\n\r\n            // Level 6 (Wallowing)\r\n            case 6:\r\n\r\n                script.introMessages = [\r\n                    \"Okay, let's move right into the next scene:\",\r\n                    \"Here, you are wallowing, right?\",\r\n                    \"You are in the pit of despair and you can't see a way out.\",\r\n                    \"This round won't be particularly hard, but you can't seem to find any matches.\"\r\n                ];\r\n\r\n                break;\r\n\r\n            // Level 7 (Pheonix Rises)\r\n            case 7:\r\n\r\n                script.introMessages = [\r\n                    \"Now, you've been wallowing. You've feeling really low.\",\r\n                    \"You're in such despair, that in this round...\",\r\n                    \"There's an obvious combo.\",\r\n                    \"Right there, right in front of your face.\",\r\n                    \"But you can't see it through the despair.\",\r\n                    \"But then, in the last ten seconds of the round, you see it.\",\r\n                    \"Boom, it's the perfect match.\",\r\n                    \"And the pheonix rises once again!\"\r\n                ];\r\n\r\n                break;\r\n\r\n            // Level 8 (Victory Lap)\r\n            case 8:\r\n\r\n                script.introMessages = [\r\n                    \"Our hero is back!\",\r\n                    \"This final scene is our victory lap.\",\r\n                    \"However, we don't want too many combos in this round, right?\",\r\n                    \"This is a round the player wins on their own.\",\r\n                    \"No assistance from the game.\",\r\n                    \"A true hero's victory!\",\r\n                    \"Alright, let's do this: I've got an appointment after this.\"\r\n                ];\r\n\r\n                break;\r\n\r\n        }\r\n\r\n        return script;\r\n    }\r\n\r\n}","export default class {\r\n\r\n    constructor()\r\n    {\r\n        this.introMessages = [];\r\n        this.getDisplayTileMatchMessages = () => {};\r\n    }\r\n}","export default class {\r\n\r\n    constructor(x, y, script)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.script = script;\r\n\r\n        this.messageTimer = null;\r\n        this.currMessageIndex = 0;\r\n        this.queuedMessages = null;\r\n    }\r\n\r\n    create(context)\r\n    {\r\n        const self = this;\r\n\r\n        const speechBubbleWidth = 500;\r\n        const speechBubbleHeight = 100;\r\n        \r\n        const characterWidth = 100;\r\n        const characterHeight = 500;\r\n\r\n        // Speech Bubble\r\n        const speechBubbleGraphics = context.add.graphics({ fillStyle: { color: 0xffffff } });\r\n        const speechBubble = new Phaser.Geom.Rectangle(this.x, this.y, speechBubbleWidth, speechBubbleHeight);\r\n        speechBubbleGraphics.fillRectShape(speechBubble);\r\n\r\n        context.input.on('pointerdown', (pointer) => {\r\n            if(speechBubble.contains(pointer.x, pointer.y))\r\n            {\r\n                self.messageTimer.paused = false;\r\n            }\r\n        });\r\n\r\n        // Speech Bubble Text\r\n        this.speechBubbleText = context.add.text(this.x + 5, this.y + 5, '', { color: '#000' });\r\n\r\n        // Character\r\n        const characterGraphics = context.add.graphics({ fillStyle: { color: 0xff0000 } });\r\n        const character = new Phaser.Geom.Rectangle(\r\n            this.x + speechBubbleWidth - characterWidth,\r\n            this.y + speechBubbleHeight + 20,\r\n            characterWidth,\r\n            characterHeight);\r\n        characterGraphics.fillRectShape(character);\r\n\r\n        self.queueMessages(context, this.script.introMessages);\r\n    }\r\n\r\n    queueMessages(context, messages)\r\n    {\r\n        if(!messages)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const self = this;\r\n\r\n        if(self.queuedMessages === null)\r\n        {\r\n            self.queuedMessages = [];\r\n        }\r\n\r\n        self.queuedMessages.push(...messages);\r\n\r\n        if(self.messageTimer != null)\r\n        {\r\n            return;\r\n        }\r\n\r\n        self.messageTimer = context.time.addEvent({\r\n            delay: 50,\r\n            callback: () => {\r\n                if(self.queuedMessages.length === 0)\r\n                {\r\n                    self.messageTimer.remove();\r\n                    self.messageTimer = null;\r\n                    resolve();\r\n                    return;\r\n                }\r\n\r\n                self.currMessageIndex++;\r\n\r\n                const currMessage = self.queuedMessages[0];\r\n\r\n                if(self.currMessageIndex > currMessage.length)\r\n                {\r\n                    self.currMessageIndex = 0;\r\n                    self.queuedMessages.shift();\r\n                    self.messageTimer.paused = true;\r\n                    return;\r\n                }\r\n\r\n                const message = currMessage.slice(0, self.currMessageIndex);\r\n                self.speechBubbleText.setText(message);\r\n            },\r\n            callbackScope: this,\r\n            loop: true\r\n        });\r\n    }\r\n\r\n    displayTileMatchMessage(context, data)\r\n    {\r\n        const messages = this.script.getDisplayTileMatchMessages(data);\r\n        this.queueMessages(context, messages);\r\n    }\r\n}","export default class extends Phaser.Scene {\r\n\r\n    constructor()\r\n    {\r\n        super('GameOverScene');\r\n\r\n        this.finalScore = 0;\r\n    }\r\n\r\n    init(data)\r\n    {\r\n        this.finalScore = data.score;\r\n    }\r\n\r\n    create()\r\n    {\r\n        const self = this;\r\n\r\n        // Title\r\n        this.add.text(50, 50, 'Game Over!');\r\n\r\n        // Score\r\n        this.add.text(50, 100, `Final Score: ${this.finalScore}`);\r\n\r\n        // \"Return to Main Menu\" Button\r\n        const startOverBtn = this.add.text(50, 150, 'Return to Main Menu');\r\n        startOverBtn.setInteractive();\r\n        startOverBtn.on('pointerdown', () => { self.scene.start('TitleScene'); });\r\n    }\r\n    \r\n}","import TitleScene from './scenes/TitleScene';\r\nimport RoundScene from './scenes/RoundScene';\r\nimport GameOverScene from './scenes/GameOverScene';\r\n\r\nconst config = {\r\n    type: Phaser.AUTO,\r\n    width: 800,\r\n    height: 1200, // 600\r\n    scene: [TitleScene, RoundScene, GameOverScene]\r\n};\r\n\r\nconst game = new Phaser.Game(config);"],"sourceRoot":""}